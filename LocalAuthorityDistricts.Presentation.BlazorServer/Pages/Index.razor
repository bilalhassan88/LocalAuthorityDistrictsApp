@page "/"
@layout MinimalLayout
@using LocalAuthorityDistricts.Application
@using LocalAuthorityDistricts.Domain
@inject IGeoJsonService GeoJsonService
@inject IJSRuntime JS

<h3>Local Authority Districts (Read-Only)</h3>

<input type="text" @bind="searchQuery" @oninput="OnSearchInput" placeholder="Search by name..." />
<button @onclick="HideAll">Hide All</button>
<button @onclick="Reload">Reload</button>

<div id="map" style="width: 100%; height: 600px;"></div>

@if (errorMessage != null)
{
    <div class="alert alert-danger">@errorMessage</div>
}

@code {
    private List<Feature> displayedFeatures = new();
    private string searchQuery = string.Empty;
    private System.Threading.Timer? debounceTimer;
    private string? errorMessage;
    private CancellationTokenSource? cts;

    private readonly string mapboxAccessToken = "pk.eyJ1IjoiYmlsYWxoYXNzYW4iLCJhIjoiY2pzZXBtZDlrMTVjZzQ0bzZmY29zNHozbCJ9.gIAwBp9pMmZUhWliI4CrfA";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeMap();
            await LoadAllDistricts();
        }
    }

    private async Task InitializeMap()
    {
        try
        {
            await JS.InvokeVoidAsync("mapboxInterop.initializeMap", mapboxAccessToken, "map");
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to initialize map: {ex.Message}";
            StateHasChanged(); // Trigger a re-render to display the error message
        }
    }

    private async Task LoadAllDistricts()
    {
        // Cancel any ongoing operation
        cts?.Cancel();
        cts = new CancellationTokenSource();

        try
        {
            displayedFeatures.Clear();
            errorMessage = null;
            StateHasChanged(); // Trigger a re-render to clear the UI

            await foreach (var feature in GeoJsonService.GetAllDistrictsAsync().WithCancellation(cts.Token))
            {
                // Check if cancellation was requested
                if (cts.Token.IsCancellationRequested)
                {
                    break; // Exit the loop if cancellation is requested
                }

                displayedFeatures.Add(feature);

                // Update map in batches (every 10 items)
                if (displayedFeatures.Count % 10 == 0)
                {
                    await UpdateMapAsync();
                }
            }

            // Final update to ensure all features appear
            if (!cts.Token.IsCancellationRequested)
            {
                await UpdateMapAsync();
            }
        }
        catch (OperationCanceledException)
        {
            // Ignore cancellation
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load districts: {ex.Message}";
            StateHasChanged(); // Trigger a re-render to display the error message
        }
    }

    private async Task OnSearchInput(ChangeEventArgs e)
    {
        searchQuery = e?.Value?.ToString() ?? string.Empty;

        // Dispose old timer (if any) and debounce user input for 300 ms
        debounceTimer?.Dispose();
        debounceTimer = new System.Threading.Timer(
            async _ => await InvokeAsync(InvokeSearch),
            null,
            300,
            System.Threading.Timeout.Infinite
        );
    }

    private async Task InvokeSearch()
    {
        // Cancel any ongoing operation
        cts?.Cancel();
        cts = new CancellationTokenSource();

        try
        {
            displayedFeatures.Clear();
            errorMessage = null;
            StateHasChanged(); // Trigger a re-render to clear the UI

            if (string.IsNullOrWhiteSpace(searchQuery))
            {
                await LoadAllDistricts();
            }
            else
            {
                await foreach (var feature in GeoJsonService.FilterByNameAsync(searchQuery).WithCancellation(cts.Token))
                {
                    // Check if cancellation was requested
                    if (cts.Token.IsCancellationRequested)
                    {
                        break; // Exit the loop if cancellation is requested
                    }

                    displayedFeatures.Add(feature);

                    // Update map in batches (every 10 items)
                    if (displayedFeatures.Count % 10 == 0)
                    {
                        await UpdateMapAsync();
                    }
                }

                if (!cts.Token.IsCancellationRequested)
                {
                    await UpdateMapAsync();
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Ignore cancellation
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to search districts: {ex.Message}";
            StateHasChanged(); // Trigger a re-render to display the error message
        }
    }

    private async Task HideAll()
    {
        try
        {
            // Cancel any ongoing operation
            cts?.Cancel();

            // Clear the displayed features and remove the layer from the map
            displayedFeatures.Clear();
            await JS.InvokeVoidAsync("mapboxInterop.removeLayer", "districtsLayer");
            StateHasChanged(); // Trigger a re-render to clear the UI
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to hide districts: {ex.Message}";
            StateHasChanged(); // Trigger a re-render to display the error message
        }
    }

    private async Task Reload()
    {
        await LoadAllDistricts(); // Restart the process of loading all districts
    }

    private async Task UpdateMapAsync()
    {
        try
        {
            var geoJson = new
            {
                type = "FeatureCollection",
                features = displayedFeatures
            };

            await JS.InvokeVoidAsync("mapboxInterop.addGeoJsonLayer", "districtsLayer", geoJson);
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to update map: {ex.Message}";
            StateHasChanged(); // Trigger a re-render to display the error message
        }
    }

    // Implement IDisposable for cleanup
    public void Dispose()
    {
        // Clean up the timer and cancellation token
        debounceTimer?.Dispose();
        cts?.Cancel();
    }
}